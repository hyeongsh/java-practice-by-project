# 문제 개선
## 문제 1: equals 오버라이드 실수
### 문제
equals(domain.Order object)로 구현하여 사용하였음
### 원인
Object.equals(Object)를 정확히 오버라이드 해야만 사용 가능
모든 객체는 Object 클래스를 상속받으므로..
### 개선
equals(Object o)로 변경
## 문제 2: containsKey + get 두 번 조회
### 문제
containsKey -> get 사용으로 두 번 조회하는 문제가 있었음
### 원인 x
### 개선
putIfAbsent를 사용하여 비어 있을 경우에만 추가하는 방식을 사용하였음.
이 경우, 반환값으로 이전 값을 반환하는데, 이게 null이 아니라면 예외를 발생

# 새 개념
## RuntimeException 상속의 특징
자바에는 Error와 Exception으로 오류가 구분된다. <br>
Error는 프로그램이 더 이상 실행될 수 없는 치명적인 오류를 말하고, Exception은 예측 가능하여 예외 처리를 통해 로직을 이어나가야 하는 종류다. <br>
Exception에는 크게 Checked Exception과 Unchecked Exception이 존재한다. <br>
### Checked Exception
RuntimeException을 상속받지 않는 모든 예외를 말하며, 컴파일러가 예외 처리를 강제한다. <br>
예외 처리를 강제한다는 뜻은 try-catch로 잡거나, throws 처리를 통해 상위 메서드에서 처리를 하도록 하지 않으면 컴파일 자체가 안되는 것을 말한다.
### Unchecked Exception
RuntimeException을 상속받는 클래스가 여기에 속하며 주로 논리적인 오류를 말한다. <br>
장점이라면 발생 지점에서 처리되지 않으면 자동으로 상위 메서드로 던져지는 전파의 자유로움이 있다. <br>
만약 예외를 잡는 코드가 없다면 main 메서드까지 올라가거나 스레드 종료가 된다. <br>
보통은 복구가 가능한 지점을 찾거나, 공통 예외 처리기에서 처리하는 것이 옳다.

## 불변 객체
불변 객체란 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말한다. <br>
따라서 객체의 내부 상태를 제공하지 않거나, 제공 시에 방어적 복사를 통해 제공한다.
### 불변 객체를 사용해야 하는 이유
1. Thread-Safe 하기 때문에 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
2. 어떤 예외가 발생하더라도 메소드 호출 전 상태 유지를 보장할 수 있다.
3. Cache나 Map, Set의 요소로 활용하기에 적합하다.
4. 순수 함수 작성을 도모하여 오류 가능성을 최소화할 수 있다.
5. 다른 사람이 작성한 함수를 예측 용이하게 해주며 안전한 사용이 가능하다.
6. 가비지 컬렉터의 성능을 높일 수 있다.
### 가비지 컬렉터의 성능이 높아지는 이유
JVM은 메모리를 Young 영역과 Old 영역으로 나누어 관리한다.<br>
Young 영역 객체가 Old 영역 객체를 참조하는 것은 흔하다. <br>
하지만 반대의 경우 GC는 이를 추적하기 위해 Card Table이라는 별도의 메모리 구역에 기록을 남긴다. <br>
만약 Old 영역에 올라간 객체가 불변 객체라면 새롭게 Young 영역에 생성된 객체를 참조할 일이 없으므로 Card Table 기록이 없어진다. 
-> Minor GC의 스캔 범위를 줄여 성능 향상을 불러옴. <br>
JVM은 수명이 짧은 객체를 처리하는 데에 매우 최적화 되어 있지만, 만약 회수 중에 Card Table을 확인해야 한다면 성능이 악화될 수 밖에 없다. <br>
현대의 JVM은 객체 생성 속도가 빠르고 GC 최적화 이점이 객체 생성 비용보다 훨씬 크므로 불변 객체를 많이 생성하는 것이 더 이득이다.
